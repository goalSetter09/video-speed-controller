{
  "rules": [
    {
      "type": "prd",
      "content": "# Video Speed Controller Chrome Extension PRD\n\n## 1. Overview\nA lightweight Chrome extension that lets online learners precisely control video playback speed with simple keyboard shortcuts and a minimal overlay. It eliminates the need to repeatedly open the player speed menu, saving time and keeping focus on the learning material.\n\n## 2. Problem Statement\nOnline learning platforms often reset playback speed between sessions, forcing users to manually adjust it each time. Existing keyboard shortcuts vary across sites and rarely support fine-grained 0.1x steps or instant toggling to a preferred speed. This breaks the learner’s flow and wastes time.\n\n## 3. Goals\n1. Remove the repetitive task of setting a desired speed for every video.\n2. Allow friction-less, fine-grained speed control without leaving the keyboard.\n3. Provide clear visual feedback of the current speed without cluttering the screen.\n\n## 4. Non-Goals\n• Site-specific presets or global cloud sync (future consideration).\n• Support for non-Chromium browsers in the initial MVP.\n• Payment, analytics, or multi-user account features.\n\n## 5. Target Users\nPrimary: Students and self-learners who watch online lectures on Chrome-based browsers (Coursera, Udemy, YouTube Edu, etc.).\n\n## 6. Use Case\nWhile watching an online lecture, the learner presses the “.” key to speed up a fast-forward segment, then taps “,” to slow down for a complex explanation, and hits “r” to jump instantly between normal speed and their preferred 1.8× speed—all without touching the mouse.\n\n## 7. Core Features (MVP)\nF1. 0.1× speed change with “,” (−) and “.” (+) keys.  \nF2. Toggle between current speed and preferred speed (default 1.8×) with “r” key.  \nF3. Small on-screen overlay at top-right showing current speed for 1.2 s after every change.  \nF4. Popup UI (extension icon) to change preferred speed value.\n\n## 8. Additional Features (Nice-to-Have for v1.1)\nA1. Popup allows editing preferred speed in real time.  \nA2. Badge text on the extension icon briefly displays current speed when it changes.\n\n## 9. Functional Requirements\nFR1. Works on all mainstream HTML5 video elements within Chrome-based browsers.  \nFR2. Keyboard listeners must not interfere with site shortcuts if the video element is not focused.  \nFR3. Preferred speed persists in browser storage (chrome.storage.local).  \nFR4. Overlay auto-hides after 1.2 s and respects dark/light backgrounds.  \nFR5. Performance overhead <1 % CPU on average while idle.\n\n## 10. Non-Functional Requirements\n• Extension size ≤ 150 KB zipped.  \n• No external network calls (privacy friendly).  \n• Must pass Chrome Web Store extension audit (even if sideloaded).\n\n## 11. Success Metrics (for personal use)\n• Personal time saved per lecture (subjective).  \n• No noticeable video stutter after speed changes.  \n• Keyboard response latency <50 ms.\n\n## 12. Technical Constraints\n• Manifest V3.  \n• Pure JavaScript (ES6) with minimal dependencies.  \n• Content script injected on all pages matching “*://*/*”.\n\n## 13. Milestones & Timeline (MVP)\nW1: Project scaffolding & manifest setup.  \nW2: Implement keyboard listeners & speed control.  \nW3: Overlay component & styling.  \nW4: Popup UI for preferred speed & storage.  \nW5: Testing on major learning sites.  \nW6: Packaging & personal sideload.\n\n## 14. Risks & Mitigations\n• Site scripts blocking content injections → use shadow DOM and CSS isolation.  \n• Keyboard shortcut collision → enable easy toggle on/off via extension popup.\n\n## 15. Future Considerations\n• Site-specific presets.  \n• Firefox port.  \n• Sync preferred speed via Chrome sync storage.",
      "writedAt": "2025-12-27T10:19:43.670Z"
    },
    {
      "type": "architecture",
      "content": "# Technical Requirements Document (TRD)\n\n## 1. Executive Technical Summary\n- **Project Overview**: 본 프로젝트는 순수 JavaScript와 Chrome Extension Manifest V3를 사용하여 온라인 학습 플랫폼의 비디오 재생 속도를 키보드 단축키로 정밀하게 제어하는 경량 브라우저 확장 프로그램을 개발하는 것을 목표로 합니다. 아키텍처는 콘텐츠 스크립트, 팝업 UI, 백그라운드 서비스 워커의 세 가지 핵심 구성 요소로 분리하여 각 기능의 독립성과 유지보수성을 확보합니다. 외부 라이브러리 의존성을 최소화하여 성능 저하 없이 신속한 사용자 경험을 제공하는 데 중점을 둡니다.\n- **Core Technology Stack**: 프론트엔드 UI는 HTML5와 CSS3로 구성하며, 핵심 로직은 JavaScript (ES6)를 사용합니다. 브라우저 통합은 Chrome Extensions Manifest V3 API를 통해 이루어지며, 사용자 설정 데이터는 Chrome Storage API (`local`)를 이용해 영속적으로 저장합니다.\n- **Key Technical Objectives**: 유휴 상태에서 평균 CPU 사용률 1% 미만, 키보드 입력 반응 지연 시간 50ms 미만, 압축된 확장 프로그램 크기 150KB 이하를 목표로 설정합니다. 모든 기능은 외부 네트워크 호출 없이 오프라인 환경에서 완벽하게 동작해야 합니다.\n- **Critical Technical Assumptions**: 사용자는 Chrome 또는 Chromium 기반 브라우저를 사용하며, 대상 비디오는 표준 HTML5 `<video>` 요소를 통해 재생된다고 가정합니다. 콘텐츠 스크립트가 모든 웹 페이지(`*://*/*`)에 주입될 수 있는 권한을 사용자가 허용할 것을 전제로 합니다.\n\n## 2. Tech Stack\n| Category | Technology / Library | Reasoning (Why it's chosen for this project) |\n| :--- | :--- | :--- |\n| **핵심 언어** | JavaScript (ES6) | 외부 종속성 없이 브라우저 확장 프로그램의 모든 로직을 구현할 수 있는 가장 직접적이고 가벼운 선택입니다. |\n| **UI 마크업/스타일링** | HTML5, CSS3 | 팝업 및 오버레이 UI를 구성하기 위한 웹 표준 기술로, 별도의 프레임워크 없이 간단하고 빠르게 개발할 수 있습니다. |\n| **브라우저 통합** | Chrome Extensions Manifest V3 | 최신 Chrome 확장 프로그램 개발 표준으로, 보안 및 성능 요구사항을 충족하며 필수적인 API를 제공합니다. |\n| **클라이언트 측 저장소** | Chrome Storage API (`local`) | 사용자의 선호 재생 속도 설정을 브라우저에 안전하고 영속적으로 저장하기 위한 네이티브 API입니다. 동기화가 필요 없는 MVP 요구사항에 적합합니다. |\n\n## 3. System Architecture Design\n\n### Top-Level building blocks\n- **콘텐츠 스크립트 (`content.js`)**\n  - 웹 페이지에 직접 주입되어 페이지의 DOM에 접근하고 조작합니다.\n  - 하위 구성 요소: 키보드 이벤트 리스너, 비디오 요소 탐색 및 제어 로직, 속도 표시 오버레이 UI 생성 및 관리 로직.\n- **팝업 UI (`popup.html`, `popup.js`)**\n  - 사용자가 확장 프로그램 아이콘을 클릭했을 때 나타나는 인터페이스입니다.\n  - 하위 구성 요소: 선호 속도 입력을 위한 HTML 폼, 설정 저장을 위한 JavaScript 로직.\n- **백그라운드 서비스 워커 (`background.js`)**\n  - 확장 프로그램의 생명주기를 관리하고 백그라운드 작업을 처리합니다.\n  - 하위 구성 요소: Manifest V3 요구사항을 충족하기 위한 최소한의 이벤트 리스너. (v1.1의 뱃지 텍스트 업데이트 기능 구현 시 메시지 수신 로직 추가)\n- **매니페스트 파일 (`manifest.json`)**\n  - 확장 프로그램의 모든 설정과 권한을 정의하는 핵심 설정 파일입니다.\n  - 하위 구성 요소: 권한(`storage`, `scripting`), 콘텐츠 스크립트 주입 규칙, 팝업 페이지 경로, 백그라운드 서비스 워커 정의.\n\n### Top-Level Component Interaction Diagram\n```mermaid\ngraph TD\n    subgraph \"사용자\"\n        A[키보드 입력]\n        B[확장 프로그램 아이콘 클릭]\n    end\n\n    subgraph \"웹 페이지\"\n        C[콘텐츠 스크립트] --> D[HTML5 비디오 요소]\n        C --> E[속도 표시 오버레이]\n    end\n\n    subgraph \"확장 프로그램\"\n        F[팝업 UI]\n        G[Chrome Storage API]\n    end\n\n    A --> C\n    B --> F\n    F --> G\n    C --> G\n```\n\n- **키보드 상호작용**: 사용자가 단축키를 누르면, 웹 페이지에 주입된 **콘텐츠 스크립트**가 이벤트를 감지하여 **HTML5 비디오 요소**의 재생 속도를 직접 변경하고 **속도 표시 오버레이**를 화면에 노출합니다.\n- **설정 변경**: 사용자가 **확장 프로그램 아이콘**을 클릭하면 **팝업 UI**가 열립니다. 사용자가 선호 속도를 입력하고 저장하면, **팝업 UI**는 이 값을 **Chrome Storage API**에 기록합니다.\n- **데이터 동기화**: **콘텐츠 스크립트**는 '선호 속도로 전환' 기능(r키)을 실행할 때 **Chrome Storage API**에서 저장된 값을 읽어와 사용합니다.\n\n### Code Organization & Convention\n**Domain-Driven Organization Strategy**\n- **Domain Separation**: 코드를 기능 도메인(`video_control`, `ui`, `storage`)을 중심으로 구성하여 각 책임 영역을 명확히 분리합니다.\n- **Layer-Based Architecture**: 확장 프로그램의 구성 요소(콘텐츠 스크립트, 팝업, 백그라운드)를 명확한 계층으로 분리하여 상호 의존성을 최소화합니다.\n- **Feature-Based Modules**: 각 도메인 내에서 관련된 기능(예: 키보드 리스너, 오버레이 관리)을 모듈 단위로 그룹화합니다.\n- **Shared Components**: 본 프로젝트의 규모가 작으므로, 별도의 공유 모듈보다는 각 스크립트 내에서 필요한 유틸리티 함수를 정의하여 단순성을 유지합니다.\n\n**Universal File & Folder Structure**\n```\n/\n├── manifest.json\n├── icons/\n│   ├── icon16.png\n│   ├── icon48.png\n│   └── icon128.png\n├── src/\n│   ├── content/\n│   │   ├── content.js\n│   │   └── content.css\n│   ├── popup/\n│   │   ├── popup.html\n│   │   ├── popup.js\n│   │   └── popup.css\n│   └── background/\n│       └── background.js\n└── README.md\n```\n\n### Data Flow & Communication Patterns\n- **Client-Server Communication**: 해당 없음. 본 확장 프로그램은 외부 네트워크 통신을 하지 않습니다.\n- **Database Interaction**: `chrome.storage.local` API를 사용하여 비동기적으로 `get` 및 `set` 메서드를 호출합니다. 데이터는 key-value 쌍(예: `{'preferredSpeed': 1.8}`)으로 저장됩니다.\n- **External Service Integration**: 해당 없음.\n- **Real-time Communication**: 해당 없음.\n- **Data Synchronization**:\n  - **팝업 -> 저장소**: `popup.js`에서 사용자가 선호 속도를 저장하면 `chrome.storage.set()`을 호출하여 데이터를 기록합니다.\n  - **콘텐츠 스크립트 <- 저장소**: `content.js`는 초기화 시 또는 'r' 키를 누를 때 `chrome.storage.get()`을 호출하여 저장된 선호 속도 값을 가져옵니다.\n\n## 4. Performance & Optimization Strategy\n- **효율적인 이벤트 리스너 관리**: 키보드 이벤트 리스너는 페이지 내에 `<video>` 요소가 존재할 경우에만 활성화하여 불필요한 자원 소모를 방지합니다. 또한, 비디오 요소가 포커스되지 않았을 때는 이벤트를 처리하지 않고 통과시켜 사이트 고유 단축키와의 충돌을 최소화합니다.\n- **최소한의 DOM 조작**: 속도 표시 오버레이는 한 번 생성된 후, 내용을 변경하고 `opacity`와 `visibility` 속성을 조절하는 방식으로 재사용합니다. `setTimeout`을 이용해 일정 시간 후 자동으로 숨겨지도록 하여 지속적인 렌더링 부하를 피합니다.\n- **경량 스크립트 유지**: 외부 라이브러리나 프레임워크를 사용하지 않고 순수 JavaScript로만 구현하여 확장 프로그램의 전체 크기와 메모리 사용량을 최소화합니다. 코드 실행 속도를 높이고 초기 로딩 시간을 단축합니다.\n- **비동기 작업 최적화**: `Chrome Storage API` 호출은 비동기적으로 처리되므로, `async/await` 또는 Promise를 사용하여 UI 블로킹 없이 데이터를 읽고 쓸 수 있도록 구현합니다.\n\n## 5. Implementation Roadmap & Milestones\n### Phase 1: Foundation (MVP Implementation)\n- **Core Infrastructure**: `manifest.json` 설정(권한, 콘텐츠 스크립트, 팝업 정의 포함), 기본 폴더 구조 생성.\n- **Essential Features**: 콘텐츠 스크립트 내 키보드 이벤트 리스너 구현(',' , '.' , 'r' 키). HTML5 비디오 요소의 `playbackRate` 제어 로직 개발. 속도 변경 시 화면 우측 상단에 오버레이 표시 및 자동 숨김 기능 구현. 팝업 UI를 통해 선호 속도 값을 `chrome.storage.local`에 저장하는 기능 구현.\n- **Basic Security**: 콘텐츠 스크립트가 페이지의 다른 스크립트와 격리되어 실행되도록 보장.\n- **Development Setup**: 로컬 환경에서 압축 해제된 확장 프로그램을 로드하고 테스트하는 개발 환경 구축.\n- **Timeline**: 6주\n\n### Phase 2: Feature Enhancement\n- **Advanced Features**: 팝업 UI에서 선호 속도를 변경할 때, 열려 있는 탭의 비디오 속도에 실시간으로 반영하는 기능 추가. 속도 변경 시 확장 프로그램 아이콘의 뱃지 텍스트에 현재 속도를 잠시 표시하는 기능 구현.\n- **Performance Optimization**: MVP 구현 후 주요 학습 사이트에서 성능을 측정하고, 병목 현상 발생 시 코드 리팩토링 진행.\n- **Enhanced Security**: 코드 검토를 통해 잠재적인 보안 취약점(예: DOM-based XSS)을 점검하고 보완.\n- **Monitoring Implementation**: (해당 없음. 개인용 프로젝트)\n- **Timeline**: MVP 완료 후 2주\n\n## 6. Risk Assessment & Mitigation Strategies\n### Technical Risk Analysis\n- **Technology Risks**: 일부 웹사이트는 커스텀 비디오 플레이어나 Shadow DOM을 사용하여 표준 `<video>` 요소 접근을 어렵게 할 수 있습니다.\n  - **Mitigation Strategies**: `document.querySelector('video')` 외에 Shadow DOM 내부를 탐색하는 로직을 추가하고, 여러 사이트에서 사용되는 공통적인 플레이어 구조를 분석하여 탐색 로직을 고도화합니다.\n- **Performance Risks**: 비디오가 많은 페이지나 저사양 컴퓨터에서 콘텐츠 스크립트의 이벤트 리스너가 성능 저하를 유발할 수 있습니다.\n  - **Mitigation Strategies**: 이벤트 리스너에 디바운싱(debouncing)을 적용하여 과도한 실행을 방지하고, 활성화된 비디오 요소에만 리스너의 로직이 동작하도록 범위를 제한합니다.\n- **Security Risks**: 웹 페이지의 CSP(Content Security Policy)가 스크립트 주입이나 특정 DOM 조작을 차단할 수 있습니다.\n  - **Mitigation Strategies**: Manifest V3의 정책을 준수하고, 인라인 스크립트나 `eval()` 사용을 완전히 배제합니다. 오버레이 UI 스타일링은 인라인 스타일 대신 별도의 CSS 파일을 통해 주입하여 CSP 제한을 우회합니다.\n- **Integration Risks**: 브라우저 업데이트로 인해 Chrome API 동작이 변경되어 확장 프로그램이 오작동할 수 있습니다.\n  - **Mitigation Strategies**: 특정 API 버전에 대한 의존성을 최소화하고, Chrome 개발자 문서를 주기적으로 확인하며 주요 변경 사항에 대응할 수 있도록 코드를 유연하게 작성합니다.\n\n### Project Delivery Risks\n- **Timeline Risks**: 다양한 웹사이트에서의 호환성 테스트가 예상보다 많은 시간을 소요할 수 있습니다.\n  - **Mitigation Strategies**: MVP 단계에서는 가장 많이 사용되는 3~5개의 주요 온라인 학습 플랫폼(예: YouTube, Udemy, Coursera)에 대한 테스트에 집중하고, 이후 점진적으로 지원 범위를 넓힙니다.\n- **Resource Risks**: (해당 없음. 개인 프로젝트)\n- **Quality Risks**: 단축키가 특정 웹사이트의 기존 단축키와 충돌하여 사용성을 해칠 수 있습니다.\n  - **Mitigation Strategies**: 팝업 UI에 확장 프로그램의 전체 기능을 켜고 끌 수 있는 토글 스위치를 추가하여 사용자가 필요에 따라 쉽게 비활성화할 수 있도록 합니다.\n- **Deployment Risks**: Chrome 웹 스토어 검수 과정에서 예기치 않은 사유로 등록이 거부될 수 있습니다.\n  - **Mitigation Strategies**: 제출 전 Chrome 웹 스토어 정책을 철저히 검토하고, 요청하는 권한(`storage`, `scripting`)의 사용 목적을 명확하게 기술합니다. 코드 난독화를 피하고 가독성 높은 코드를 제출하여 검수 과정을 원활하게 합니다.",
      "writedAt": "2025-12-27T10:19:43.670Z"
    },
    {
      "type": "guideline",
      "content": "# Code Guideline: Video Speed Controller Chrome Extension\n\n## 1. Project Overview\n\nThis document establishes the official coding standards for the Video Speed Controller, a lightweight Chrome Extension built with Manifest V3. The project's architecture is centered around three isolated components: a **Content Script** (`content.js`) for DOM manipulation and event handling, a **Popup UI** (`popup.js`) for user configuration, and a minimal **Background Service Worker** (`background.js`).\n\nThe core technology stack consists of pure JavaScript (ES6), HTML5, and CSS3, with `chrome.storage.local` serving as the sole persistence layer. The primary architectural goals are performance, minimal footprint, and clear separation of concerns between the extension's components.\n\n## 2. Core Principles\n\n- **Simplicity Over Complexity**: Write clear, straightforward, and self-documenting code.\n- **Performance First**: Prioritize efficient DOM access, event handling, and minimal resource consumption.\n- **Clear Separation of Concerns**: Each script (`content`, `popup`, `background`) must have a distinct and non-overlapping responsibility.\n- **Defensive Coding**: Assume the web page environment is unpredictable; handle potential null elements and API errors gracefully.\n\n## 3. Language-Specific Guidelines\n\n### File Organization and Directory Structure\n\nAll source code **MUST** reside within the `/src` directory, following the structure defined in the TRD. This separation ensures a clean distinction between the extension's functional domains.\n\n```\n/src/\n├── content/\n│   ├── content.js      # Logic for video control and overlay\n│   └── content.css     # Styles for the speed overlay\n├── popup/\n│   ├── popup.html      # Markup for the popup\n│   ├── popup.js        # Logic for the popup UI and storage\n│   └── popup.css       # Styles for the popup\n└── background/\n    └── background.js   # Background service worker (minimal)\n```\n\n### Import/Dependency Management\n\nThis project **MUST NOT** use any external JavaScript libraries or frameworks to maintain a minimal footprint and optimal performance.\n\nCommunication between the extension's components (e.g., `popup.js` and `content.js`) **MUST** be achieved asynchronously via `chrome.storage` API, not direct function calls or shared state.\n\n### Error Handling Patterns\n\nAll interactions with the Chrome API and potentially failing DOM queries **MUST** be wrapped in appropriate error handling blocks.\n\n- **Chrome API Calls**: Use `async/await` with `try...catch` blocks. The Chrome Extension APIs in Manifest V3 return Promises, which simplifies asynchronous code.\n- **DOM Manipulation**: Before manipulating a DOM element, **MUST** check if it exists to prevent runtime errors on pages without video elements.\n\n```javascript\n// MUST: Use async/await and check for elements before use.\nasync function getPreferredSpeed() {\n  try {\n    const data = await chrome.storage.local.get('preferredSpeed');\n    return data.preferredSpeed || 1.8; // Return default if not set\n  } catch (error) {\n    console.error('Error retrieving preferred speed:', error);\n    return 1.8; // Fallback to default on error\n  }\n}\n\nfunction updateVideoSpeed(videoElement, newSpeed) {\n  if (!videoElement) {\n    // Defensively exit if the video element is not found.\n    return;\n  }\n  videoElement.playbackRate = newSpeed;\n}\n```\n\n## 4. Code Style Rules\n\n### MUST Follow:\n\n1.  **Use `const` by default, `let` only if a variable must be reassigned.**\n    *   *Rationale*: This prevents accidental reassignment and makes the code's intent clearer.\n\n2.  **Use `async/await` for all asynchronous operations (e.g., `chrome.storage`).**\n    *   *Rationale*: It improves readability and maintainability compared to callback chains or `.then()`.\n\n3.  **Adhere to a consistent naming convention.**\n    *   `camelCase` for variables and functions (e.g., `preferredSpeed`, `updateOverlay`).\n    *   `UPPER_SNAKE_CASE` for constants (e.g., `DEFAULT_SPEED`, `OVERLAY_TIMEOUT`).\n    *   Prefix DOM element variables with `$` or end with `Element` (e.g., `$speedInput` or `speedInputElement`).\n\n4.  **Encapsulate logic within Immediately Invoked Function Expressions (IIFE) in content scripts.**\n    *   *Rationale*: This prevents polluting the global `window` object of the host page, avoiding conflicts with the page's own scripts.\n\n    ```javascript\n    // MUST: Wrap content script logic in an IIFE.\n    (() => {\n      const PREFERRED_SPEED_KEY = 'preferredSpeed';\n      // All your content script logic goes here...\n    })();\n    ```\n\n5.  **Use single-responsibility functions.**\n    *   *Rationale*: Small, focused functions are easier to understand, test, and reuse. A function should do one thing well.\n\n    ```javascript\n    // MUST: Break down complex logic into smaller functions.\n    function initialize() {\n      const video = findActiveVideoElement();\n      if (video) {\n        addKeyboardListeners(video);\n      }\n    }\n\n    function findActiveVideoElement() {\n      return document.querySelector('video');\n    }\n\n    function addKeyboardListeners(videoElement) {\n      // ... listener logic\n    }\n    ```\n\n### MUST NOT Do:\n\n1.  **Do not use `var`.**\n    *   *Rationale*: `var` has function-scoping rules that can lead to unexpected behavior. `let` and `const` provide block-scoping, which is more predictable.\n\n2.  **Do not write large, monolithic files or functions.**\n    *   *Rationale*: Large blocks of code are difficult to read, debug, and maintain. Break down files like `content.js` into logical sections using comments or helper objects.\n\n3.  **Do not use inline styles or inline event handlers in HTML.**\n    *   *Rationale*: This violates the separation of concerns (HTML, CSS, JS) and is blocked by Manifest V3's Content Security Policy (CSP). Always use `.css` files and `element.addEventListener()`.\n\n    ```html\n    <!-- MUST NOT: Inline styles and event handlers are prohibited. -->\n    <button id=\"save\" style=\"color: blue;\" onclick=\"saveSettings()\">Save</button>\n    ```\n\n    ```javascript\n    // MUST: Separate concerns.\n    // In popup.js\n    const saveButton = document.getElementById('save');\n    saveButton.addEventListener('click', saveSettings);\n\n    // In popup.css\n    #save {\n      color: blue;\n    }\n    ```\n\n4.  **Do not directly access the `window` object of the host page for storing data.**\n    *   *Rationale*: This is insecure and can conflict with the host page's scripts. All persistent state **MUST** be stored in `chrome.storage`.\n\n## 5. Architecture Patterns\n\n### Component/Module Structure\n\nWithin each script (e.g., `content.js`), logic should be grouped into conceptual modules using plain objects or functions. This improves organization without adding complexity.\n\n```javascript\n// MUST: In content.js, group related logic into objects.\nconst VideoController = {\n  get videoElement() {\n    return document.querySelector('video');\n  },\n  changeSpeed(delta) {\n    if (this.videoElement) {\n      this.videoElement.playbackRate = Math.max(0.1, this.videoElement.playbackRate + delta);\n      return this.videoElement.playbackRate;\n    }\n    return null;\n  },\n  // ... other video-related methods\n};\n\nconst OverlayUI = {\n  // ... methods to create, show, and hide the overlay\n};\n\n// Main execution logic\ndocument.addEventListener('keydown', (event) => {\n  // ... event handling logic using VideoController and OverlayUI\n});\n```\n\n### Data Flow Pattern\n\nThe data flow for settings is unidirectional and asynchronous, ensuring a clear and predictable state management pattern.\n\n1.  **Write**: The user interacts with `popup.html`. `popup.js` validates the input and writes the new setting to `chrome.storage.local`.\n2.  **Read**: `content.js` reads the setting from `chrome.storage.local` during its initialization and whenever the \"toggle preferred speed\" key is pressed.\n\n### State Management\n\nThe single source of truth for all user-configurable settings (e.g., `preferredSpeed`) **MUST** be `chrome.storage.local`. No state should be shared or duplicated between the popup and content scripts.\n\n```javascript\n// MUST: Define a consistent key and structure for stored data.\nconst STORAGE_KEYS = {\n  PREFERRED_SPEED: 'preferredSpeed'\n};\n\nconst DEFAULTS = {\n  [STORAGE_KEYS.PREFERRED_SPEED]: 1.8\n};\n\n// In popup.js - Writing to storage\nasync function savePreferredSpeed(speed) {\n  await chrome.storage.local.set({ [STORAGE_KEYS.PREFERRED_SPEED]: speed });\n}\n\n// In content.js - Reading from storage\nasync function getPreferredSpeed() {\n  const data = await chrome.storage.local.get(DEFAULTS);\n  return data[STORAGE_KEYS.PREFERRED_SPEED];\n}\n```\n\n### API Design Standards\n\nSince this extension has no external API, \"API Design\" refers to the contract for data stored in `chrome.storage`.\n\n-   Keys **MUST** be defined as constants in a shared location or duplicated consistently (given the project's small scale).\n-   Stored values **MUST** be simple data types (numbers, strings, booleans). Avoid storing complex objects unless necessary.\n-   Always provide a default value when reading from storage to handle the initial run case gracefully.",
      "writedAt": "2025-12-27T10:19:43.670Z"
    },
    {
      "type": "design-guide",
      "content": "# Video Speed Controller Chrome Extension Design Guide\n\n## 1. Overall Mood (전체적인 무드)\n\n온라인 학습자들을 위한 신뢰할 수 있고 전문적인 도구로서의 무드를 추구합니다. 학습에 방해되지 않는 미니멀하고 깔끔한 디자인을 통해 사용자가 콘텐츠에 집중할 수 있도록 지원합니다. 쿨톤 계열의 차분한 색상과 중간 정도의 채도를 사용하여 안정감과 신뢰성을 전달하며, 불필요한 시각적 요소를 배제한 기능 중심의 인터페이스를 제공합니다.\n\n## 2. Reference Service (참조 서비스)\n\n- **Name**: Notion\n- **Description**: 올인원 워크스페이스 및 노트 작성 도구\n- **Design Mood**: 깔끔하고 미니멀한 디자인, 넉넉한 여백과 단순한 구분선을 활용한 차분한 인터페이스\n- **Primary Color**: #1F6FEB\n- **Secondary Color**: #1E3A5F\n\n## 3. Color & Gradient (색상 & 그라데이션)\n\n- **Primary Color**: #1F6FEB (딥 블루) - 버튼, 하이라이트, 액티브 상태\n- **Secondary Color**: #1E3A5F (네이비) - 배경, 호버 상태\n- **Accent Color**: #FFD64D (소프트 옐로우) - 성공 상태, 포커스 링\n- **Background Light**: #F5F7FA - 팝업 배경\n- **Text Dark**: #1A1A1A - 주요 텍스트\n- **Text Gray**: #8A8F98 - 비활성 아이콘, 보조 텍스트\n- **Divider**: #E3E6EA - 구분선\n- **Overlay Background**: #1E3A5F (80% 투명도) - 오버레이 배경\n- **Mood**: 쿨톤, 중간 채도\n- **Color Usage**: Primary는 가장 중요한 액션 버튼과 활성 상태에, Secondary는 배경과 보조 요소에, Accent는 포커스와 성공 피드백에 사용\n\n## 4. Typography & Font (타이포그래피 & 폰트)\n\n- **Font Family**: Inter, system fallback (San Francisco, Segoe UI)\n- **Heading 1 (Title)**: Inter, 16px, Weight 600\n- **Body**: Inter, 14px, Weight 400\n- **Caption**: Inter, 12px, Weight 400\n- **Button Text**: Inter, 14px, Weight 500\n- **Overlay Text**: Inter, 14px, Weight 700 (Bold)\n- **Letter Spacing**: 기본값 사용\n- **Line Height**: 1.4 (제목), 1.5 (본문)\n\n## 5. Layout & Structure (레이아웃 & 구조)\n\n- **Grid System**: 8px 기준 그리드 시스템 사용\n- **Popup Dimensions**: 240×160px (기본), 최대 280px (고해상도 디스플레이)\n- **Spacing**: 16px (large), 12px (medium), 8px (small), 4px (tight)\n- **Border Radius**: 4px (컨테이너), 6px (버튼)\n- **Shadow**: 0 2px 8px rgba(0, 0, 0, 0.1) (팝업)\n- **Overlay Position**: 화면 우상단, 16px margin\n- **Padding**: 16px (팝업 내부), 12px (버튼), 8px (인풋 필드)\n\n## 6. Visual Style (비주얼 스타일)\n\n- **Icon Style**: Feather 또는 Heroicons Solid 스타일의 라인 아이콘\n- **Icon Stroke Width**: 2px\n- **Icon Colors**: #1F6FEB (활성), #8A8F98 (비활성)\n- **Icon Sizes**: 16×16px (인터페이스), 128×128px (Chrome 스토어)\n- **Image Treatment**: SVG 형식 우선 사용\n- **Illustration Style**: 미니멀하고 기하학적인 형태\n- **Asset Variants**: 16×16, 32×32, 48×48, 128×128px\n\n## 7. UX Guide (UX 가이드)\n\n- **Target Users**: 전문가와 초보자 모두 고려\n- **Expert Users**: 즉시 사용 가능한 키보드 단축키 제공\n- **Beginner Users**: 첫 실행 시 툴팁과 튜토리얼 링크 제공\n- **Information Architecture**: 고급 옵션은 기본적으로 숨김 처리\n- **Interaction Pattern**: 키보드 우선, 마우스 보조\n- **Feedback Strategy**: 시각적 오버레이로 즉각적인 피드백 제공\n- **Error Prevention**: 명확한 레이블과 안내 메시지\n- **Accessibility**: 키보드 네비게이션 완전 지원, 스크린 리더 호환\n\n## 8. UI Component Guide (UI 컴포넌트 가이드)\n\n### 8.1 팝업 카드 (Popup Card)\n- **Size**: 240×160px\n- **Background**: #F5F7FA\n- **Border Radius**: 8px\n- **Shadow**: 0 4px 12px rgba(0, 0, 0, 0.15)\n- **Padding**: 16px\n- **Title**: \"선호 속도\" (16px, Weight 600, #1A1A1A)\n\n### 8.2 숫자 입력 필드 (Numeric Input)\n- **Width**: 120px\n- **Height**: 36px\n- **Border**: 1px solid #E3E6EA\n- **Border Radius**: 4px\n- **Focus State**: 2px outline #FFD64D\n- **Step**: 0.1\n- **Font**: 14px, Weight 400\n\n### 8.3 버튼 (Buttons)\n- **Primary Button**:\n  - Background: #1F6FEB\n  - Color: #FFFFFF\n  - Height: 36px\n  - Padding: 12px 16px\n  - Border Radius: 6px\n  - Hover: #1557C7\n- **Secondary Button**:\n  - Background: transparent\n  - Border: 1px solid #E3E6EA\n  - Color: #1A1A1A\n  - Hover: #F5F7FA\n\n### 8.4 오버레이 배지 (Overlay Badge)\n- **Background**: #1E3A5F (80% 투명도)\n- **Color**: #FFFFFF\n- **Font**: 14px, Weight 700\n- **Padding**: 8px 12px\n- **Border Radius**: 4px\n- **Animation**: 150ms ease-out fade\n- **Duration**: 1.2초 후 자동 숨김\n\n### 8.5 아코디언 (Accordion)\n- **Header**: 14px, Weight 500, #1A1A1A\n- **Icon**: 16×16px 화살표\n- **Padding**: 12px 0\n- **Border**: 1px solid #E3E6EA (하단)\n- **Animation**: 200ms ease-in-out\n\n### 8.6 툴팁 (Tooltip)\n- **Size**: 300×200px\n- **Background**: #FFFFFF\n- **Border**: 1px solid #E3E6EA\n- **Border Radius**: 8px\n- **Shadow**: 0 8px 24px rgba(0, 0, 0, 0.12)\n- **Arrow**: 8px triangle pointing to target\n\n### 8.7 포커스 링 (Focus Ring)\n- **Color**: #FFD64D\n- **Width**: 2px\n- **Style**: solid outline\n- **Offset**: 2px\n\n### 8.8 상태 표시 (Status Indicators)\n- **Success**: #22C55E\n- **Warning**: #F59E0B\n- **Error**: #EF4444\n- **Info**: #3B82F6\n\n### 8.9 모션 및 전환 (Motion & Transitions)\n- **Overlay Fade**: 150ms ease-out\n- **Button Hover**: 100ms ease-in-out\n- **Focus Transition**: 100ms ease-in-out\n- **Accordion Expand**: 200ms ease-in-out\n\n### 8.10 반응형 규칙 (Responsive Rules)\n- **High DPI**: 최대 너비 280px\n- **Device Pixel Ratio**: 오버레이 크기 자동 조정\n- **Minimum Touch Target**: 44×44px (모바일 고려)",
      "writedAt": "2025-12-27T10:19:43.670Z"
    },
    {
      "type": "ia",
      "content": "# Video Speed Controller Chrome Extension Information Architecture (IA)\n\n## 1. Site Map (사이트맵)\n\n```\nChrome Extension Root\n├── Content Script Layer (콘텐츠 스크립트 계층)\n│   ├── 키보드 단축키 리스너\n│   ├── 비디오 속도 제어 로직\n│   ├── 속도 표시 오버레이\n│   └── 온보딩 툴팁 모달\n├── Popup Interface (팝업 인터페이스)\n│   ├── 메인 설정 화면\n│   ├── 고급 옵션 (아코디언)\n│   └── 튜토리얼 링크\n├── Tutorial Page (튜토리얼 페이지)\n│   ├── 단축키 가이드\n│   ├── 사용법 설명\n│   └── 완료 버튼\n└── Background Service (백그라운드 서비스)\n    ├── 스토리지 관리\n    └── 전역 상태 관리\n```\n\n## 2. User Flow (사용자 흐름)\n\n### 주요 작업 1: 확장 프로그램 설치 및 초기 설정\n1. 사용자가 Chrome 확장 프로그램을 설치합니다.\n2. 첫 번째 비디오 페이지 방문 시 온보딩 툴팁이 표시됩니다.\n3. 툴팁에서 기본 단축키 안내를 확인합니다.\n4. \"시작하기\" 버튼을 클릭하여 툴팁을 닫습니다.\n5. 확장 프로그램 아이콘을 클릭하여 팝업을 엽니다.\n6. 선호 속도를 2.0배속으로 변경합니다.\n7. 설정이 자동 저장됩니다.\n\n### 주요 작업 2: 비디오 시청 중 속도 조절\n1. 온라인 강의 비디오를 재생합니다.\n2. \"r\" 키를 눌러 1.0배속에서 2.0배속으로 변경합니다.\n3. 화면 우상단에 \"2.0×\" 오버레이가 1.2초간 표시됩니다.\n4. 어려운 구간에서 \",\" 키를 3번 눌러 1.7배속으로 감속합니다.\n5. 각 키 입력마다 오버레이가 업데이트됩니다.\n6. \"r\" 키를 다시 눌러 1.0배속으로 복귀합니다.\n\n### 주요 작업 3: 고급 설정 변경\n1. 확장 프로그램 아이콘을 클릭합니다.\n2. \"고급 옵션\" 아코디언을 펼칩니다.\n3. \"배지 표시 활성화\" 체크박스를 선택합니다.\n4. 설정이 자동 저장되고 팝업을 닫습니다.\n\n## 3. Navigation Structure (네비게이션 구조)\n\n### 주 네비게이션\n- **확장 프로그램 아이콘**: 팝업 인터페이스 접근점\n- **키보드 단축키**: 직접적인 기능 실행 (네비게이션 불필요)\n\n### 팝업 내부 네비게이션\n- **메인 설정 영역**: 선호 속도 입력 필드\n- **고급 옵션**: 아코디언 방식으로 접기/펼치기\n- **튜토리얼 링크**: 새 탭에서 도움말 페이지 열기\n\n### 모달 네비게이션\n- **온보딩 툴팁**: 첫 실행 시 자동 표시, 닫기 버튼으로 해제\n- **속도 오버레이**: 자동 표시/숨김, 사용자 조작 불가\n\n## 4. Page Hierarchy (페이지 계층 구조)\n\n```\n/ (Extension Root - Depth 0)\n├── /content-scripts (Depth 1)\n│   ├── /video-controller.js (Depth 2)\n│   ├── /overlay-injector.js (Depth 2)\n│   └── /onboarding-tooltip.js (Depth 2)\n├── /popup (Depth 1)\n│   ├── /popup.html (Depth 2)\n│   ├── /popup.js (Depth 2)\n│   └── /popup.css (Depth 2)\n├── /tutorial (Depth 1)\n│   ├── /tutorial.html (Depth 2)\n│   ├── /tutorial.js (Depth 2)\n│   └── /tutorial.css (Depth 2)\n├── /background (Depth 1)\n│   └── /background.js (Depth 2)\n└── /assets (Depth 1)\n    ├── /icons (Depth 2)\n    └── /styles (Depth 2)\n```\n\n## 5. Content Organization (콘텐츠 구성)\n\n| 컴포넌트 | 주요 콘텐츠 요소 |\n|---|---|\n| 팝업 메인 화면 | 제목 \"선호 속도\", 숫자 입력 필드, 저장 버튼 |\n| 고급 옵션 | 아코디언 헤더, 배지 활성화 체크박스, 설명 텍스트 |\n| 속도 오버레이 | 현재 속도 표시 (예: \"1.8×\"), 반투명 배경 |\n| 온보딩 툴팁 | 환영 메시지, 단축키 목록, 시작하기 버튼 |\n| 튜토리얼 페이지 | 단축키 표, 사용법 설명, 예시 시나리오, 완료 버튼 |\n\n## 6. Interaction Patterns (인터랙션 패턴)\n\n### 키보드 우선 인터랙션\n- **속도 증가**: \".\" 키로 0.1배속씩 증가\n- **속도 감소**: \",\" 키로 0.1배속씩 감소\n- **토글**: \"r\" 키로 현재 속도와 선호 속도 간 전환\n\n### 시각적 피드백 패턴\n- **즉시 피드백**: 키 입력 시 오버레이 즉시 표시\n- **자동 숨김**: 1.2초 후 오버레이 자동 페이드아웃\n- **부드러운 전환**: 150ms ease-out 애니메이션\n\n### 설정 저장 패턴\n- **자동 저장**: 입력 필드 변경 시 즉시 chrome.storage.local에 저장\n- **실시간 반영**: 저장된 설정이 모든 탭의 비디오에 즉시 적용\n\n### 모달 및 툴팁 패턴\n- **첫 실행 온보딩**: 설치 후 첫 비디오 페이지 방문 시 자동 표시\n- **아코디언 확장**: 고급 옵션을 기본적으로 숨김, 클릭 시 확장\n\n## 7. URL Structure (URL 구조)\n\n### 확장 프로그램 내부 리소스\n- **팝업**: `chrome-extension://[extension-id]/popup/popup.html`\n- **튜토리얼**: `chrome-extension://[extension-id]/tutorial/tutorial.html`\n- **아이콘**: `chrome-extension://[extension-id]/assets/icons/[size].png`\n\n### 콘텐츠 스크립트 주입 대상\n- **모든 HTTP/HTTPS 페이지**: `*://*/*`\n- **비디오 요소 감지**: HTML5 `<video>` 태그가 있는 페이지\n\n## 8. Component Hierarchy (컴포넌트 계층 구조)\n\n### 전역 컴포넌트 (Global Components)\n- **SpeedOverlay**: 모든 비디오 페이지에서 사용되는 속도 표시 오버레이\n- **KeyboardListener**: 전역 키보드 이벤트 처리기\n- **StorageManager**: chrome.storage.local 접근 관리자\n\n### 팝업 컴포넌트 (Popup Components)\n- **PopupContainer**: 팝업의 최상위 컨테이너 (240×160px)\n- **PreferredSpeedInput**: 선호 속도 설정 숫자 입력 필드\n- **AdvancedOptionsAccordion**: 고급 설정 접기/펼치기 영역\n- **SaveButton**: 설정 저장 버튼 (자동 저장으로 향후 제거 예정)\n- **TutorialLink**: 도움말 페이지 연결 링크\n\n### 온보딩 컴포넌트 (Onboarding Components)\n- **OnboardingTooltip**: 첫 실행 시 표시되는 안내 모달\n- **ShortcutGuide**: 키보드 단축키 안내 테이블\n- **WelcomeMessage**: 환영 메시지 및 기본 설명\n\n### 튜토리얼 컴포넌트 (Tutorial Components)\n- **TutorialContainer**: 튜토리얼 페이지 레이아웃 컨테이너\n- **ShortcutTable**: 단축키와 기능 설명 표\n- **UsageExample**: 실제 사용 시나리오 예시\n- **CompletionButton**: 튜토리얼 완료 버튼\n\n### 상태 관리 컴포넌트 (State Management Components)\n- **PreferredSpeedStore**: 선호 속도 값 저장 및 관리\n- **VideoElementTracker**: 현재 페이지의 비디오 요소 추적\n- **SpeedHistoryManager**: 이전 속도 기록 관리 (토글 기능용)\n\n### 접근성 컴포넌트 (Accessibility Components)\n- **FocusManager**: 키보드 네비게이션 순서 관리\n- **ScreenReaderAnnouncer**: 스크린 리더를 위한 상태 변경 알림\n- **HighContrastSupport**: 고대비 모드 지원",
      "writedAt": "2025-12-27T10:19:43.670Z"
    },
    {
      "type": "step-by-step",
      "content": "\n## Core Directive\nYou are a senior software engineer AI assistant. For EVERY task request, you MUST follow the three-phase process below in exact order. Each phase must be completed with expert-level precision and detail.\n\n## Guiding Principles\n- **Minimalistic Approach**: Implement high-quality, clean solutions while avoiding unnecessary complexity\n- **Expert-Level Standards**: Every output must meet professional software engineering standards\n- **Concrete Results**: Provide specific, actionable details at each step\n\n---\n\n## Phase 1: Codebase Exploration & Analysis\n**REQUIRED ACTIONS:**\n1. **Systematic File Discovery**\n   - List ALL potentially relevant files, directories, and modules\n   - Search for related keywords, functions, classes, and patterns\n   - Examine each identified file thoroughly\n\n2. **Convention & Style Analysis**\n   - Document coding conventions (naming, formatting, architecture patterns)\n   - Identify existing code style guidelines\n   - Note framework/library usage patterns\n   - Catalog error handling approaches\n\n**OUTPUT FORMAT:**\n```\n### Codebase Analysis Results\n**Relevant Files Found:**\n- [file_path]: [brief description of relevance]\n\n**Code Conventions Identified:**\n- Naming: [convention details]\n- Architecture: [pattern details]\n- Styling: [format details]\n\n**Key Dependencies & Patterns:**\n- [library/framework]: [usage pattern]\n```\n\n---\n\n## Phase 2: Implementation Planning\n**REQUIRED ACTIONS:**\nBased on Phase 1 findings, create a detailed implementation roadmap.\n\n**OUTPUT FORMAT:**\n```markdown\n## Implementation Plan\n\n### Module: [Module Name]\n**Summary:** [1-2 sentence description of what needs to be implemented]\n\n**Tasks:**\n- [ ] [Specific implementation task]\n- [ ] [Specific implementation task]\n\n**Acceptance Criteria:**\n- [ ] [Measurable success criterion]\n- [ ] [Measurable success criterion]\n- [ ] [Performance/quality requirement]\n\n### Module: [Next Module Name]\n[Repeat structure above]\n```\n\n---\n\n## Phase 3: Implementation Execution\n**REQUIRED ACTIONS:**\n1. Implement each module following the plan from Phase 2\n2. Verify ALL acceptance criteria are met before proceeding\n3. Ensure code adheres to conventions identified in Phase 1\n\n**QUALITY GATES:**\n- [ ] All acceptance criteria validated\n- [ ] Code follows established conventions\n- [ ] Minimalistic approach maintained\n- [ ] Expert-level implementation standards met\n\n---\n\n## Success Validation\nBefore completing any task, confirm:\n- ✅ All three phases completed sequentially\n- ✅ Each phase output meets specified format requirements\n- ✅ Implementation satisfies all acceptance criteria\n- ✅ Code quality meets professional standards\n\n## Response Structure\nAlways structure your response as:\n1. **Phase 1 Results**: [Codebase analysis findings]\n2. **Phase 2 Plan**: [Implementation roadmap]  \n3. **Phase 3 Implementation**: [Actual code with validation]\n",
      "writedAt": "2025-12-27T10:19:43.670Z"
    },
    {
      "type": "clean-code",
      "content": "\n# Clean Code Guidelines\n\nYou are an expert software engineer focused on writing clean, maintainable code. Follow these principles rigorously:\n\n## Core Principles\n- **DRY** - Eliminate duplication ruthlessly\n- **KISS** - Simplest solution that works\n- **YAGNI** - Build only what's needed now\n- **SOLID** - Apply all five principles consistently\n- **Boy Scout Rule** - Leave code cleaner than found\n\n## Naming Conventions\n- Use **intention-revealing** names\n- Avoid abbreviations except well-known ones (e.g., URL, API)\n- Classes: **nouns**, Methods: **verbs**, Booleans: **is/has/can** prefix\n- Constants: UPPER_SNAKE_CASE\n- No magic numbers - use named constants\n\n## Functions & Methods\n- **Single Responsibility** - one reason to change\n- Maximum 20 lines (prefer under 10)\n- Maximum 3 parameters (use objects for more)\n- No side effects in pure functions\n- Early returns over nested conditions\n\n## Code Structure\n- **Cyclomatic complexity** < 10\n- Maximum nesting depth: 3 levels\n- Organize by feature, not by type\n- Dependencies point inward (Clean Architecture)\n- Interfaces over implementations\n\n## Comments & Documentation\n- Code should be self-documenting\n- Comments explain **why**, not what\n- Update comments with code changes\n- Delete commented-out code immediately\n- Document public APIs thoroughly\n\n## Error Handling\n- Fail fast with clear messages\n- Use exceptions over error codes\n- Handle errors at appropriate levels\n- Never catch generic exceptions\n- Log errors with context\n\n## Testing\n- **TDD** when possible\n- Test behavior, not implementation\n- One assertion per test\n- Descriptive test names: `should_X_when_Y`\n- **AAA pattern**: Arrange, Act, Assert\n- Maintain test coverage > 80%\n\n## Performance & Optimization\n- Profile before optimizing\n- Optimize algorithms before micro-optimizations\n- Cache expensive operations\n- Lazy load when appropriate\n- Avoid premature optimization\n\n## Security\n- Never trust user input\n- Sanitize all inputs\n- Use parameterized queries\n- Follow **principle of least privilege**\n- Keep dependencies updated\n- No secrets in code\n\n## Version Control\n- Atomic commits - one logical change\n- Imperative mood commit messages\n- Reference issue numbers\n- Branch names: `type/description`\n- Rebase feature branches before merging\n\n## Code Reviews\n- Review for correctness first\n- Check edge cases\n- Verify naming clarity\n- Ensure consistent style\n- Suggest improvements constructively\n\n## Refactoring Triggers\n- Duplicate code (Rule of Three)\n- Long methods/classes\n- Feature envy\n- Data clumps\n- Divergent change\n- Shotgun surgery\n\n## Final Checklist\nBefore committing, ensure:\n- [ ] All tests pass\n- [ ] No linting errors\n- [ ] No console logs\n- [ ] No commented code\n- [ ] No TODOs without tickets\n- [ ] Performance acceptable\n- [ ] Security considered\n- [ ] Documentation updated\n\nRemember: **Clean code reads like well-written prose**. Optimize for readability and maintainability over cleverness.\n",
      "writedAt": "2025-12-27T10:19:43.670Z"
    }
  ]
}